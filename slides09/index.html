<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8" /><meta name="author" content="Иван Пономарёв, КУРС/МФТИ" /><title>Core Java: Курс лекций. Лекция 9</title><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><link href="reveal.js-3.7.0/css/reveal.css" rel="stylesheet" /><link rel="stylesheet" href="white_course.css" id="theme" /><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="./font-awesome-4.7.0/css/font-awesome.css" /><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js-3.7.0/lib/css/zenburn.css" rel="stylesheet" /><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js-3.7.0/css/print/pdf.css" : "reveal.js-3.7.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js-3.7.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Core Java</h1><h2>Курс лекций. Лекция 9</h2><div class="preamble"><div class="paragraph"><p><a href="mailto:ponomarev@corchestra.ru">ponomarev@corchestra.ru</a></p></div>
<div class="paragraph"><p><span class="icon"><i class="fa fa-twitter fa-lg"></i></span> @inponomarev</p></div></div><p class="author"><small>Иван Пономарёв, КУРС/МФТИ</small></p></section>
<section id="_streams"><h2>Streams</h2><div class="ulist"><ul><li><p>Появились в Java8, вместе с lambdas &amp; method references.</p></li><li><p>Обработка конечных и потенциально бесконечных наборов данных.</p></li><li><p>Декларативный подход к обработке данных: описываем <strong>что</strong> хотим получить, а не <strong>как</strong> мы это получим.</p></li><li><p>Прозрачный параллелизм.</p></li></ul></div></section>
<section id="_преобразуем_поток_в_поток"><h2>Преобразуем поток в поток</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p><code>blockStream</code></p></div>
<div class="imageblock" style=""><img src="images/map.svg" alt="map" /></div>
<div class="paragraph"><p><code>squashedStream</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">List</span>&lt;Block&gt; blocks = ...;

Stream&lt;Block&gt; blocksStream = blocks.stream();

Stream&lt;SquashedBlock&gt; squashedStream =
  blocksStream.map(Block::squash);</code></pre>
<div class="paragraph"><p>(Автор анимаций&#8201;&#8212;&#8201;Тагир Валеев, движущиеся картинки см. <a href="https://stackoverflow.com/questions/35150231/java-streams-lazy-vs-fusion-vs-short-circuiting">здесь</a>)</p></div></div></td></tr></table></section>
<section id="_фильтруем"><h2>Фильтруем</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p><code>squashedStream</code></p></div>
<div class="imageblock" style=""><img src="images/filter.svg" alt="filter" /></div>
<div class="paragraph"><p><code>filteredStream</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">Stream&lt;SquashedBlock&gt; filteredStream =
  squashedStream.filter(block <span class="error">‑</span>&gt;
         block.getColor() != YELLOW);</code></pre></div></td></tr></table></section>
<section id="_отображаем_в_консоль_терминальная_операция"><h2>Отображаем в консоль (терминальная операция)</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="paragraph"><p><code>filteredStream</code></p></div>
<div class="imageblock" style=""><img src="images/display.svg" alt="display" /></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">filteredStream
  .forEach(<span class="predefined-type">System</span>.out::println);</code></pre></div></td></tr></table></section>
<section id="_всё_вместе_в_одну_строку"><h2>Всё вместе в одну строку</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="imageblock" style=""><img src="images/fuse.svg" alt="fuse" /></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">blocks.stream()
      .map(Block::squash)
      .filter(block <span class="error">‑</span>&gt;
         block.getColor() != YELLOW)
      .forEach(<span class="predefined-type">System</span>.out::println);</code></pre></div></td></tr></table></section>
<section id="_ничего_не_напоминает"><h2>Ничего не напоминает?</h2><div class="paragraph"><p>«Соединить два файла, привести их строки к lowercase, отсортировать, вывести три последних строки в алфавитном порядке»</p></div>
<pre class="CodeRay listingblock"><code class="sh language-sh">cat file1 file2 | tr &quot;[A-Z]&quot; &quot;[a-z]&quot; | sort | tail -3</code></pre></section>
<section id="_зачем_это_нужно"><h2>Зачем это нужно?</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:55%" /><col style="width:45%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Java 7</strong></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Java 8</strong></p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;<span class="predefined-type">Currency</span>, <span class="predefined-type">List</span>&lt;Transaction&gt;&gt;
 transactionsByCurrencies = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

<span class="keyword">for</span> (Transaction transaction : transactions) {
 <span class="predefined-type">Currency</span> currency =transaction.getCurrency();
 <span class="predefined-type">List</span>&lt;Transaction&gt; transactionsForCurrency =
   transactionsByCurrencies.get(currency);
 <span class="keyword">if</span> (transactionsForCurrency == <span class="predefined-constant">null</span>) {
  transactionsForCurrency = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
    transactionsByCurrencies.put(currency,
           transactionsForCurrency);
 }
 transactionsForCurrency.add(transaction);
}</code></pre></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;<span class="predefined-type">Currency</span>,
 <span class="predefined-type">List</span>&lt;Transaction&gt;&gt;
 transactionsByCurr =
   transactions
   .stream()
   .collect(
     Collectors
     .groupingBy(
   Transaction
   ::getCurrency));</code></pre></div></td></tr></table></section>
<section id="_три_категории_методов_stream_api"><h2>Три категории методов Stream API</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Создание стрима</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; names = menu.stream()

<span class="comment">//Промежуточные операции</span>
  .filter(d -&gt; d.getCalories() &gt; <span class="integer">300</span>
  .map(Dish::getName)
  .limit(<span class="integer">3</span>)

<span class="comment">//Терминальная операция</span>
  .collect(Collectors.toList());</code></pre></section>
<section id="_создание_стрима"><h2>Создание стрима</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Пустого</span>
Stream&lt;Foo&gt; stream0 = Stream.empty();

<span class="comment">//Перечислением элементов</span>
Stream&lt;<span class="predefined-type">String</span>&gt; stream1 =
         Stream.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">gently</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">down</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">the</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">stream</span><span class="delimiter">&quot;</span></span>);
<span class="comment">//Из массива</span>
Stream&lt;<span class="predefined-type">String</span>&gt; stream2 =
         <span class="predefined-type">Arrays</span>.stream(<span class="string"><span class="delimiter">&quot;</span><span class="content">gently down the stream</span><span class="delimiter">&quot;</span></span>.split(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>));
<span class="comment">//Из коллекции</span>
<span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings = ...
Stream&lt;<span class="predefined-type">String</span>&gt; stream3 = strings.stream();

<span class="comment">//Из API</span>
Path path = Paths.get(...);
Stream&lt;Path&gt; stream4 = Files.list(path);</code></pre></section>
<section id="_конкатенация_стримов"><h2>Конкатенация стримов</h2><pre class="CodeRay listingblock"><code class="java language-java">Stream&lt;Foo&gt; s1 = ...;
Stream&lt;Foo&gt; s2 = ...;
Stream&lt;Foo&gt; s = Stream.concat(s1, s2);</code></pre></section>
<section id="_порождение_стримов_generate"><h2>Порождение стримов (generate)</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//С помощью генератора</span>
Stream&lt;<span class="predefined-type">Double</span>&gt; randoms =
    Stream.generate(<span class="predefined-type">Math</span>::random);</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java">          <span class="comment">//ХОТЯ ЛУЧШЕ</span>
          DoubleStream doubles =
            ThreadLocalRandom.current().doubles()</code></pre></section>
<section id="_порождение_стримов_iterate"><h2>Порождение стримов (iterate)</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Итеративно</span>
Stream&lt;<span class="predefined-type">Integer</span>&gt; integers =
    Stream.iterate(<span class="integer">0</span>, x -&gt; x + <span class="integer">1</span>);</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java">          <span class="comment">//ХОТЯ ЛУЧШЕ</span>
          IntStream range = IntStream.range(<span class="integer">0</span>, <span class="integer">1000</span>);</code></pre></section>
<section id="_что_будет_в_этом_стриме"><h2>Что будет в этом стриме?</h2><pre class="CodeRay listingblock"><code class="java language-java">    Stream.iterate(<span class="keyword">new</span> <span class="type">int</span><span class="type">[]</span>{<span class="integer">0</span>, <span class="integer">1</span>},
                   t -&gt; <span class="keyword">new</span> <span class="type">int</span><span class="type">[]</span>{t[<span class="integer">1</span>], t[<span class="integer">0</span>] + t[<span class="integer">1</span>]})
    .mapToInt(t -&gt; t[<span class="integer">0</span>]);</code></pre></section>
<section id="_spliterator_самый_общий_способ_создания_стрима"><h2>Spliterator: самый общий способ создания стрима</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Spliterator</span>&lt;T&gt; {
  <span class="type">boolean</span> tryAdvance(Consumer&lt;? <span class="local-variable">super</span> T&gt; action);
  Spliterator&lt;T&gt; trySplit();
  <span class="type">long</span> estimateSize();
  <span class="type">int</span> characteristics();
}</code></pre>
<pre class="CodeRay listingblock"><code class="java language-java">StreamSupport.stream(Spliterator&lt;T&gt; spliterator, <span class="type">boolean</span> parallel)</code></pre></section>
<section id="_ветвление_сплитераторов"><h2>Ветвление сплитераторов</h2><div class="imageblock" style=""><img src="images/split1.png.png" alt="split1.png" /></div></section>
<section id="_ветвление_сплитераторов_2"><h2>Ветвление сплитераторов</h2><div class="imageblock" style=""><img src="images/split2.png.png" alt="split2.png" /></div></section>
<section id="_характеристики_сплитератора"><h2>Характеристики сплитератора</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:15%" /><col style="width:85%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>ORDERED</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Elements have a defined order (for example, a <code>List</code>), so the <code>Spliterator</code> enforces this
order when traversing and partitioning them.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>DISTINCT</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>For each pair of elements <code>x</code> and <code>y</code>, <code>x.equals(y)</code> returns <code>false</code>.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>SORTED</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The traversed elements follow a predefined sort order.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>SIZED</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>This <code>Spliterator</code> has been created from a source with a known size, so the value returned by <code>estimatedSize()</code> is precise.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>NONNULL</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>It’s guaranteed that the traversed elements won’t be null.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>IMMUTABLE</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The source of this <code>Spliterator</code> can’t be modified. This implies that no elements can be
added, removed, or modified during their traversal.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>CONCURRENT</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The source of this <code>Spliterator</code> may be safely concurrently modified by other threads
without any synchronization.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>SUBSIZED</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Both this <code>Spliterator</code> and all further <code>Spliterators</code> resulting from its split are <code>SIZED</code>.</p></div></div></td></tr></table></section>
<section id="_промежуточные_итоги"><h2>Промежуточные итоги</h2><div class="ulist"><ul><li><p>Есть много стандартных способов порождения стримов, для простых случаев не надо "изобретать велосипед"</p></li><li><p>Скорей всего, вам не понадобится самому реализовывать <code>Spliterator</code>.</p></li><li><p>Быстродействия ради, есть "примитивные стримы" (три типа):</p><div class="ulist"><ul><li><p><code>IntStream</code> (эффективнее, чем <code>Stream&lt;Integer&gt;</code>)</p></li><li><p><code>LongStream</code> (эффективнее, чем <code>Stream&lt;Long&gt;</code>)</p></li><li><p><code>DoubleStream</code> (эффективнее, чем <code>Stream&lt;Double&gt;</code>)</p></li></ul></div></li></ul></div></section>
<section id="_преобразования_стримов_в_стримы_получение_головы_и_хвоста"><h2>Преобразования стримов в стримы: получение «головы» и «хвоста»</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//методы интерфейса Stream</span>

<span class="comment">//голова</span>
Stream&lt;T&gt; limit(<span class="type">long</span> maxSize)
Stream&lt;T&gt; takeWhile(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate)

<span class="comment">//хвост</span>
Stream&lt;T&gt; skip(<span class="type">long</span> n)
Stream&lt;T&gt; dropWhile(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate)</code></pre></section>
<section id="_filter"><h2>filter</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="imageblock" style=""><img src="images/filter.svg" alt="filter" /></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">Stream&lt;T&gt; filter(
   <span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate);</code></pre></div></td></tr></table></section>
<section id="_map"><h2>map</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-center valign-top"><div><div class="imageblock" style=""><img src="images/map.svg" alt="map" /></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? <span class="local-variable">super</span> T,
                           ? <span class="directive">extends</span> R&gt; mapper);
IntStream mapToInt(
             ToIntFunction&lt;? <span class="local-variable">super</span> T&gt; mapper);
LongStream mapToLong(
            ToLongFunction&lt;? <span class="local-variable">super</span> T&gt; mapper);
DoubleStream mapToDouble(
          ToDoubleFunction&lt;? <span class="local-variable">super</span> T&gt; mapper);</code></pre></div></td></tr></table></section>
<section id="_flatmap"><h2>flatMap</h2><pre class="CodeRay listingblock"><code class="java language-java">Path path = ...
Pattern separator = <span class="predefined-type">Pattern</span>.compile(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">s</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">try</span>(Stream&lt;<span class="predefined-type">String</span>&gt; lines = Files.lines(path, StandardCharsets.UTF_8)) {
    <span class="comment">//НЕ ТО, что нам надо!</span>
    <span class="comment">//Stream&lt;Stream&lt;String&gt;&gt; streamStream =</span>
    <span class="comment">//                  lines.map(separator::splitAsStream);</span>

    <span class="comment">//ТО, что нам надо!</span>
    Stream&lt;<span class="predefined-type">String</span>&gt; words = lines.flatMap(separator::splitAsStream);
    words.forEach(<span class="predefined-type">System</span>.out::println);
}

<span class="comment">/*А также:
  flatMapToDouble
  flatMapToInt
  flatMapToLong
  */</span></code></pre></section>
<section id="_distinct"><h2>distinct</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Внутренний Set</span>

Stream.of(<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">5</span>, <span class="integer">9</span>, <span class="integer">9</span>)
    .distinct()
    .forEach(<span class="predefined-type">System</span>.out::println);

<span class="comment">//Выведет 1, 5, 8, 7, 9</span></code></pre></section>
<section id="_что_произойдёт_при_выполнении_такого_кода"><h2>Что произойдёт при выполнении такого кода?</h2><pre class="CodeRay listingblock"><code class="java language-java">ThreadLocalRandom.current().ints(<span class="integer">1</span>, <span class="integer">10</span>)
  .distinct()
  .forEach(<span class="predefined-type">System</span>.out::println);</code></pre>
<div class="paragraph fragment"><p>Программа зависнет, когда исчерпаются все значения от 1 до 10. Можно пофиксить, например, указав <code>limit(9)</code> после distinct.</p></div></section>
<section id="_sorted"><h2>sorted</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Внутренний отсортированный список</span>

Stream.of(<span class="integer">1</span>, <span class="integer">5</span>, <span class="integer">8</span>, <span class="integer">7</span>, <span class="integer">8</span>, <span class="integer">5</span>, <span class="integer">9</span>, <span class="integer">9</span>)
    .sorted()
    .forEach(<span class="predefined-type">System</span>.out::println);

<span class="comment">//Выведет 1, 5, 5, 7, 8, 8, 9, 9</span>

<span class="comment">//Не имеет смысла для бесконечных стримов</span></code></pre></section>
<section id="_peekотладочный_метод"><h2>peek&#8201;&#8212;&#8201;отладочный метод</h2><div class="ulist"><ul><li><p>Не меняет исходный стрим.</p></li><li><p>Предназначен для «подглядывания» за промежуточным состоянием элементов.</p></li><li><p>В качестве аргумента часто используется <code>System.out::println</code>.</p></li><li><p>При параллельных вычислениях может быть вызван в произвольном порядке в произвольном потоке выполнения.</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java">Stream&lt;T&gt; peek(Consumer&lt;? <span class="local-variable">super</span> T&gt; action);</code></pre></section>
<section id="_терминальные_операции"><h2>Терминальные операции</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Предъяви первый элемент</span>
Optional&lt;T&gt; findFirst();
<span class="comment">//Предъяви любой элемент</span>
Optional&lt;T&gt; findAny();

<span class="comment">//Проверь, удовлетворяет ли условию...</span>
<span class="comment">//...какой-то</span>
<span class="type">boolean</span> anyMatch(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate);
<span class="comment">//...все</span>
<span class="type">boolean</span> allMatch(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate);
<span class="comment">//...никакой</span>
<span class="type">boolean</span> noneMatch(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate);

<span class="comment">//КОРОТКИЕ ЗАМЫКАНИЯ!</span></code></pre></section>
<section id="_foreach"><h2>forEach</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">void</span> forEach(Consumer&lt;? <span class="local-variable">super</span> T&gt; action);</code></pre>
<div class="ulist"><ul><li><p>В случае параллельного выполнения нет гарантий последовательности</p></li><li><p>Нет гарантий относительно того, в каком потоке будет выполнена лямбда</p></li></ul></div></section>
<section id="_reduce_with_identity"><h2>reduce (with identity)</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style=""><img src="images/reduce1.png.png" alt="reduce1.png" /></div></div></td><td class="tableblock halign-left valign-top"><div><div class="ulist"><ul><li><p>Ассоциативная функция + "identity value"</p></li><li><p>Промежуточные результаты&#8201;&#8212;&#8201;immutable values</p></li><li><p>Вопрос: назовите примеры ассоциативных операций в математике?</p></li></ul></div>
<pre class="CodeRay listingblock"><code>T reduce(T identity,
  BinaryOperator&lt;T&gt; accumulator);</code></pre></div></td></tr></table></section>
<section id="_parallel_reduce"><h2>Parallel reduce</h2><div class="imageblock" style=""><img src="images/reduce-par.png.png" alt="reduce par.png" /></div></section>
<section id="_reduce_без_identity"><h2>reduce без identity</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style=""><img src="images/reduce2.png.png" alt="reduce2.png" /></div></div></td><td class="tableblock halign-left valign-top"><div><div class="ulist"><ul><li><p>identity не нужно, но и результата может не получиться (если стрим пустой)</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java">Optional&lt;T&gt; reduce(
  BinaryOperator&lt;T&gt; accumulator);</code></pre></div></td></tr></table></section>
<section id="_готовые_редьюсы"><h2>Готовые редьюсы</h2><div class="ulist"><ul><li><p>Доступный во всех стримах:</p><div class="ulist"><ul><li><p><code>count</code>&#8201;&#8212;&#8201;в общем случае требует пересчёта всех элементов!</p></li><li><p><code>max(Comparator)</code>, <code>min(Comparator)</code></p></li></ul></div></li><li><p>Доступные в стримах примитивов:</p><div class="ulist"><ul><li><p><code>sum</code></p></li><li><p><code>average</code></p></li><li><p><code>summaryStatistics</code>&#8201;&#8212;&#8201;count, sum, min и max «в одном флаконе».</p></li></ul></div></li></ul></div></section>
<section id="_collect_самый_гибкий_метод_сборки_результатов"><h2>collect: самый гибкий метод сборки результатов</h2><div class="ulist"><ul><li><p>Типовые параметры:</p><div class="ulist"><ul><li><p><code>T</code>&#8201;&#8212;&#8201;тип элементов стрима</p></li><li><p><code>A</code>&#8201;&#8212;&#8201;тип аккумулятора, промежуточной структуры данных, в которой всё собирается</p></li><li><p><code>R</code>&#8201;&#8212;&#8201;тип результата</p></li></ul></div></li><li><p>В отличие от <code>reduce</code>, работающего с иммутабельными объектами, мутирует аккумулятор.</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java">&lt;R, A&gt; R collect(Collector&lt;? <span class="local-variable">super</span> T, A, R&gt; collector);</code></pre></section>
<section id="_интерфейс_collectort_a_r"><h2>Интерфейс Collector&lt;T, A, R&gt;</h2><div class="ulist"><ul><li><p><code>T</code>&#8201;&#8212;&#8201;тип элементов стрима</p></li><li><p><code>A</code>&#8201;&#8212;&#8201;тип аккумулятора, промежуточной структуры данных, в которой всё собирается</p></li><li><p><code>R</code>&#8201;&#8212;&#8201;тип результата</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Collector</span>&lt;T, A, R&gt; {
  Supplier&lt;A&gt; supplier();
  BiConsumer&lt;A, T&gt; accumulator();
  Function&lt;A, R&gt; finisher();
  BinaryOperator&lt;A&gt; combiner();
  <span class="predefined-type">Set</span>&lt;Characteristics&gt; characteristics();
}

<span class="comment">//например:</span>
<span class="type">class</span> <span class="class">ToListCollector</span>&lt;T&gt; <span class="directive">implements</span>
   Collector&lt;T, <span class="predefined-type">List</span>&lt;T&gt;, <span class="predefined-type">List</span>&lt;T&gt;&gt;</code></pre></section>
<section id="_характеристики_коллектора"><h2>Характеристики коллектора</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:20%" /><col style="width:80%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Characteristic</strong></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Meaning</strong></p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>CONCURRENT</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Indicates that this collector is_concurrent_, meaning that the result container can support the accumulator function being called concurrently with the same result container from multiple threads.</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>UNORDERED</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Indicates that the collection operation does not commit to preserving the encounter order of input elements.  (This might be true if the result container has no intrinsic order, such as a <code>Set</code>.)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>IDENTITY_FINISH</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Indicates that the finisher function is the identity function and can be elided.  If set, it must be the case that an unchecked cast from A to R will succeed.</p></div></div></td></tr></table></section>
<section id="_промежуточные_выводы"><h2>Промежуточные выводы</h2><div class="ulist"><ul><li><p>Сделать свой коллектор непросто,</p></li><li><p>Но сила коллекторов в том, что есть много готовых и их можно комбинировать!</p></li></ul></div></section>
<section id="_наиболее_употребимые_коллекторы"><h2>Наиболее употребимые коллекторы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//java.util.stream.Collectors</span>
Collector&lt;T, ?, <span class="predefined-type">List</span>&lt;T&gt;&gt; toList()
Collector&lt;T, ?, <span class="predefined-type">Set</span>&lt;T&gt;&gt; toSet()
Collector&lt;T, ?, C <span class="directive">extends</span> <span class="predefined-type">Collection</span>&lt;T&gt;&gt;
  toCollection(Supplier&lt;C&gt; collectionFactory)

<span class="comment">//Пример применения</span>
Stream&lt;Foo&gt; myStream = ...
List&lt;Foo&gt; list = myStream.collect(Collectors.toList());</code></pre></section>
<section id="_собирание_в_мапы"><h2>Собирание в мапы</h2><pre class="CodeRay listingblock"><code class="java language-java">Collector&lt;T, ?, <span class="predefined-type">Map</span>&lt;K,U&gt;&gt; toMap(
  Function&lt;? <span class="local-variable">super</span> T, ? <span class="directive">extends</span> K&gt; keyMapper,
  Function&lt;? <span class="local-variable">super</span> T, ? <span class="directive">extends</span> U&gt; valueMapper)

<span class="comment">//Пример применения</span>
Stream&lt;Person&gt; people = ...
Map&lt;<span class="predefined-type">Integer</span>, Person&gt; idToPerson = people.collect(
  Collectors.toMap(Person::getId, p-&gt;p);</code></pre>
<div class="ulist"><ul><li><p>Также можно указать <code>mergeFunction</code> и <code>mapSupplier</code>.</p></li></ul></div></section>
<section id="_вариации_на_тему_сборки_в_коллекции"><h2>Вариации на тему сборки в коллекции</h2><div class="ulist"><ul><li><p>с помощью <code>toUnmodifiable(List|Set|Map)</code> можно сразу получить неизменяемую коллекцию</p></li><li><p><code>toConcurrentMap</code> можно сразу получить потокобезопасную мапу.</p></li></ul></div></section>
<section id="_строка_с_разделителями"><h2>Строка с разделителями</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">static</span> Collector&lt;<span class="predefined-type">CharSequence</span>, ?, <span class="predefined-type">String</span>&gt; joining()

<span class="comment">//Пример использования</span>
menuStream.map(Dish::getName).collect(Collectors.joining(<span class="string"><span class="delimiter">&quot;</span><span class="content">, </span><span class="delimiter">&quot;</span></span>);

<span class="comment">//Не забываем про то, что это же можно сделать и без стримов:</span>
<span class="directive">static</span> <span class="predefined-type">String</span> join(<span class="predefined-type">CharSequence</span> delimiter,
            <span class="predefined-type">Iterable</span>&lt;? <span class="directive">extends</span> <span class="predefined-type">CharSequence</span>&gt; elements)</code></pre></section>
<section id="_группировки"><h2>Группировки</h2><div class="imageblock" style=""><img src="images/groupby.png.png" alt="groupby.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">List</span>&lt;Dish&gt;&gt; dishesByType =
  menu.stream().collect(Collectors.groupingBy(Dish::getType));</code></pre></section>
<section id="_downstream_collectors"><h2>Downstream Collectors</h2><div class="imageblock" style=""><img src="images/groupbyby.png.png" alt="groupbyby.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">Map</span>&lt;Dish.CaloricLevel, <span class="predefined-type">List</span>&lt;Dish&gt;&gt;&gt;
  dishesByTypeAndCaloricLevel =
    menu.stream().collect(Collectors
      .groupingBy(Dish::getType,
         Collectors.groupingBy(Dish::getCaloricLevel)));</code></pre></section>
<section id="_но_мы_можем_не_только_группировать_в_цепочке"><h2>Но мы можем не только группировать в цепочке!</h2><div class="imageblock" style=""><img src="images/groupbyandcount.png.png" alt="groupbyandcount.png" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, <span class="predefined-type">Long</span>&gt; typesCount =
  menu.stream().collect(Collectors
    .groupingBy(Dish::getType, Collectors.counting()));</code></pre></section>
<section id="_набор_downstream_collectors"><h2>Набор downstream collectors</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">/*Всё это уже есть в стримах, но нам надо применить это
к &quot;разветвлённому&quot; стриму.*/</span>


<span class="comment">/*&quot;Терминальные&quot;*/</span>
counting()
summingInt(ToIntFunction&lt;? <span class="local-variable">super</span> T&gt; mapper)
summingLong(ToLongFunction&lt;? <span class="local-variable">super</span> T&gt; mapper)
summingDouble(ToDoubleFunction&lt;? <span class="local-variable">super</span> T&gt; mapper)
maxBy(<span class="predefined-type">Comparator</span>&lt;? <span class="local-variable">super</span> T&gt; comparator)
minBy(<span class="predefined-type">Comparator</span>&lt;? <span class="local-variable">super</span> T&gt; comparator)</code></pre></section>
<section id="_downstream_collectorsпродолжение"><h2>Downstream collectors&#8212;&#8203;продолжение</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">/*С возможностью продолжить цепочку*/</span>
filtering(<span class="predefined-type">Predicate</span>&lt;? <span class="local-variable">super</span> T&gt; predicate, downstream)
mapping(Function&lt;? <span class="local-variable">super</span> T, ? <span class="directive">extends</span> U&gt; mapper, downstream)
flatMapping(Function&lt;? <span class="local-variable">super</span> T,
  ? <span class="directive">extends</span> Stream&lt;? <span class="directive">extends</span> U&gt;&gt; mapper, downstream)

<span class="comment">/*Адаптор*/</span>
collectingAndThen(Collector&lt;T,A,R&gt; downstream,
  Function&lt;R,RR&gt; finisher)</code></pre></section>
<section id="_когда_может_быть_нужен_collectingandthen"><h2>Когда может быть нужен collectingAndThen?</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">Map</span>&lt;Dish.Type, Dish&gt; mostCaloricByType =
  menu.stream()
     .collect(Collectors.groupingBy(Dish::getType,
       collectingAndThen( <span class="comment">//&lt;-----АДАПТОР</span>
         Collectors.maxBy(<span class="predefined-type">Comparator</span>
                   .comparingInt(Dish::getCalories),
         <span class="comment">//maxBy возвращает Optional</span>
       Optional::get)));</code></pre></section>
<section id="_параллельные_стримы"><h2>Параллельные стримы</h2><div class="ulist"><ul><li><p>Метод <code>.parallel()</code> включает параллелизацию обработки.</p></li><li><p><code>parallel</code> можно вызвать в любом месте цепочки вызовов.</p></li><li><p>Пользоваться надо с осторожностью, понимая ограничения и применимость.</p></li></ul></div></section>
<section id="_optional_контейнер_который_содержит_объект_или_не_содержит"><h2>Optional: Контейнер, который содержит объект. Или не содержит.</h2><div class="ulist"><ul><li><p>Цитата из книги Java 8 in Action:</p></li><li><p>"Tony Hoare, one of the giants of computer science, said in a presentation at QCon London 2009: <em>I call it my billion-dollar mistake. It was the invention of the null reference in 1965&#8230;&#8203;. I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement.</em>"</p></li></ul></div></section>
<section id="_optionaltкак_стрим_из_0_или_1_элемента"><h2>Optional&lt;T&gt;&#8201;&#8212;&#8201;как стрим из 0 или 1 элемента</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Создание</span>
Optional.empty(); <span class="comment">//пустой</span>
Optional.of(x); <span class="comment">//NPE если x == null</span>
Optional.ofNullable(x); <span class="comment">//пустой или с x-ом</span>

<span class="comment">//Расчехление</span>
o.get();
o.orElse(other);
o.orElseGet(()-&gt;calcOther());
o.orElseThrow(()-&gt;<span class="keyword">new</span> <span class="exception">IllegalStateException</span>());</code></pre></section>
<section id="_optional_map"><h2>Optional.map</h2><pre class="CodeRay listingblock"><code class="java language-java">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance);
Optional&lt;<span class="predefined-type">String</span>&gt; name = optInsurance.map(Insurance::getName);</code></pre></section>
<section id="_optional_flatmap"><h2>Optional.flatMap</h2><pre class="CodeRay listingblock"><code class="java language-java">Optional&lt;Person&gt; person = ...

<span class="comment">//person.map(Person::getCar) вернёт Optional&lt;Optional&lt;Car&gt;&gt;!!</span>

String insuranceName = person.flatMap(Person::getCar)
                             .flatMap(Car::getInsurance)
                             .map(Insurance::getName)
                             .orElse(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown</span><span class="delimiter">&quot;</span></span>);</code></pre></section>
<section id="_optional_filter"><h2>Optional.filter</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="predefined-type">String</span> insuranceName = person.filter(p -&gt; p.getAge() &gt;= minAge)
                             .flatMap(Person::getCar)
                             .flatMap(Car::getInsurance)
                             .map(Insurance::getName)
                             .orElse(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unknown</span><span class="delimiter">&quot;</span></span>);</code></pre></section>
<section id="_правила_использования_optional"><h2>Правила использования Optional</h2><div class="paragraph"><p>«Лобовое» использование <code>Optional</code>&#8201;&#8212;&#8201;хуже, чем <code>null</code>:</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>ПЛОХО</strong></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>НОРМАЛЬНО</strong></p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">if</span> (o.isPresent())
  o.get().someMethod();</code></pre></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">if</span> (o != <span class="predefined-constant">null</span>)
  o.someMethod();</code></pre></div></td></tr></table></section>
<section id="_правила_использования_optional_2"><h2>Правила использования Optional</h2><div class="ulist"><ul><li><p>Переменная с типом <code>Optional</code> никогда не должна быть <code>null</code>.</p></li><li><p>Поля с типом <code>Optional</code> бесполезны: проверка на «непустоту» этого поля не лучше проверки на <code>null</code>, цена&#8201;&#8212;&#8201;дополнительный объект.</p></li><li><p>Не кладите <code>Optional</code>-ы в коллекции.</p></li><li><p>В целом, <code>Optional</code>&#8201;&#8212;&#8201;для возвращаемых значений, а не для аргументов методов.</p></li></ul></div></section>
<section id="_когда_стримы_использовать_не_нужно"><h2>Когда стримы использовать не нужно</h2><div class="ulist"><ul><li><p>Стримы многим нравятся</p></li><li><p>Иногда люди перестают думать, и случается «стримоз»</p></li><li><p>Тагир Валеев: <a href="https://habr.com/ru/post/337350/">Используйте Stream API проще (или не используйте вообще)</a></p></li></ul></div></section>
<section id="_что_не_так"><h2>Что не так?</h2><pre class="CodeRay listingblock"><code class="java language-java">collection.stream().forEach(...)</code></pre>
<div class="paragraph fragment"><p>У класса <code>Collection</code> уже есть метод <code>forEach</code>, стрим создавать не нужно.</p></div></section>
<section id="_что_не_так_2"><h2>Что не так?</h2><pre class="CodeRay listingblock"><code class="java language-java">collection.stream().collect(Collectors.toList())
collection.stream().collect(Collectors.toSet())</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*так эффективнее*/</span>
<span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;(collection)
<span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(collection)</code></pre></section>
<section id="_что_не_так_3"><h2>Что не так?</h2><pre class="CodeRay listingblock"><code class="java language-java">collection.stream().max(<span class="predefined-type">Comparator</span>.naturalOrder()).get()</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*То же самое, с меньшим количеством мусора*/</span>
<span class="predefined-type">Collections</span>.max(collection)</code></pre></section>
<section id="_что_хотел_сказать_автор"><h2>Что хотел сказать автор?</h2><pre class="CodeRay listingblock"><code class="java language-java">stream.sorted(comparator).findFirst()</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java">stream.min(comparator)</code></pre></section>
<section id="_как_улучшить"><h2>Как улучшить?</h2><pre class="CodeRay listingblock"><code class="java language-java">stream.collect(Collectors.counting())</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Коллекторы counting(), maxBy(), minBy(), reducing(), mapping(), ...
нужны лишь как вторичные в каскадных операциях groupingBy*/</span>
stream.count()</code></pre></section>
<section id="_что_не_так_4"><h2>Что не так?!</h2><pre class="CodeRay listingblock"><code class="java language-java">collection.stream().count()</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Без пересчёта элементов один за другим!*/</span>
collection.size()</code></pre></section>
<section id="_как_улучшить_2"><h2>Как улучшить?</h2><pre class="CodeRay listingblock"><code class="java language-java">listOfLists.stream().flatMap(<span class="predefined-type">List</span>::stream).count()</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Число элементов каждого подсписка известно!*/</span>
listOfLists.stream().mapToInt(<span class="predefined-type">List</span>::size).sum()</code></pre></section>
<section id="_как_улучшить_3"><h2>Как улучшить?</h2><pre class="CodeRay listingblock"><code class="java language-java">stream.filter(condition).findFirst().isPresent()</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Зачем сам элемент, если надо лишь проверить наличие?*/</span>
stream.anyMatch(condition)</code></pre></section>
<section id="_как_улучшить_4"><h2>Как улучшить?</h2><pre class="CodeRay listingblock"><code class="java language-java">stream.filter(condition).anyMatch(x -&gt; <span class="predefined-constant">true</span>)
stream.map(condition).anyMatch(b -&gt; b)
stream.map(condition).anyMatch(<span class="predefined-type">Boolean</span>::booleanValue)
stream.map(condition).anyMatch(<span class="predefined-type">Boolean</span>.TRUE::equals)</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Замысловатые вариации на простую тему*/</span>
stream.anyMatch(condition)</code></pre></section>
<section id="_как_улучшить_5"><h2>Как улучшить?!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">if</span>(stream.filter(condition).count() &gt; <span class="integer">0</span>)</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*В этом примере ещё хуже, чем в предыдущих,
т. к. обходится весь стрим целиком! А решение то же:*/</span>
<span class="keyword">if</span>(stream.anyMatch(condition))</code></pre></section>
<section id="_как_улучшить_6"><h2>Как улучшить?!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">if</span>(stream.count() &gt; <span class="integer">2</span>)</code></pre>
<pre class="CodeRay listingblock fragment"><code class="java language-java"><span class="comment">/*Нам ведь неважно, сколько их, если их больше двух?*/</span>
stream.limit(<span class="integer">3</span>).count()</code></pre></section>
<section id="_выводы"><h2>Выводы</h2><div class="ulist"><ul><li><p>«Декларативный» подход к использованию стримов, «описываем <em>что</em>, а не <em>как</em>» не отменяет понимания того, <em>как</em> происходит вычисление.</p></li><li><p>Применять стримы надо с умом, а много где их и не надо применять.</p></li></ul></div></section></div></div><script src="reveal.js-3.7.0/lib/js/head.min.js"></script><script src="reveal.js-3.7.0/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'none',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1600,
  height: 900,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js-3.7.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'reveal.js-3.7.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js-3.7.0/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>