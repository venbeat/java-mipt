<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8" /><meta name="author" content="Иван Пономарёв, КУРС/МФТИ" /><title>Core Java: Курс лекций. Лекция 10</title><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><link href="reveal.js-3.7.0/css/reveal.css" rel="stylesheet" /><link rel="stylesheet" href="white_course.css" id="theme" /><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="./font-awesome-4.7.0/css/font-awesome.css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({
tex2jax: {
  inlineMath: [["\\(", "\\)"]],
  displayMath: [["\\[", "\\]"]],
  ignoreClass: "nostem|nolatexmath"
},
asciimath2jax: {
  delimiters: [["\\$", "\\$"]],
  ignoreClass: "nostem|noasciimath"
},
TeX: { equationNumbers: { autoNumber: "none" } }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.4.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js-3.7.0/lib/css/zenburn.css" rel="stylesheet" /><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js-3.7.0/css/print/pdf.css" : "reveal.js-3.7.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js-3.7.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Core Java</h1><h2>Курс лекций. Лекция 10</h2><div class="preamble"><div class="paragraph"><p><a href="mailto:ponomarev@corchestra.ru">ponomarev@corchestra.ru</a></p></div>
<div class="paragraph"><p><span class="icon"><i class="fa fa-twitter fa-lg"></i></span> @inponomarev</p></div></div><p class="author"><small>Иван Пономарёв, КУРС/МФТИ</small></p></section>
<section id="_concurrencyконкурентное_выполнение"><h2>Concurrency&#8201;&#8212;&#8201;конкурентное выполнение</h2><div class="ulist"><ul><li><p>Одна программа&#8201;&#8212;&#8201;много одновременно выполняющихся тредов (threads)</p></li><li><p>Зачем нам вообще Concurrency?</p></li></ul></div>
<div class="paragraph fragment"><p>&#8201;&#8212;&#8201;Для перформанса, чтобы побыстрее!</p></div></section>
<section id="_где_мы_можем_получить_выгоду_от_concurrency"><h2>Где мы можем получить выгоду от concurrency?</h2><div class="ulist"><ul><li><p>Много CPU-ядер, вычислительная задача хорошо разделяется на подзадачи.</p></li><li><p>Подзадачи блокируются на вводе/выводе, можно параллельно ждать других или делать что-то полезное.</p></li><li><p>Нужно быстро отреагировать на запрос, а потом дать детальный ответ (пользовательский интерфейс).</p></li><li><p>Многопользовательский сервис (каждый запрос в своём треде).</p></li></ul></div></section>
<section id="_где_мы_не_можем_получить_выгоду_от_увеличения_concurrency"><h2>Где мы НЕ можем получить выгоду от [увеличения] concurrency?</h2><div class="ulist"><ul><li><p>CPU-bound задача не будет решаться быстрее, если тредов больше, чем ядер.</p></li><li><p>Задача плохо параллелизуется (упирается в неразделяемый ресурс).</p></li><li><p>Нас ограничивает закон Амдала.</p></li></ul></div></section>
<section id="_закон_амдала_amdahls_law"><h2>Закон Амдала (Amdahl&#8217;s law)</h2><div class="ulist"><ul><li><p>&alpha;&#8201;&#8212;&#8201;доля вычислений, которая должна выполняться последовательно,</p></li><li><p><em>N</em>&#8201;&#8212;&#8201;число параллельных потоков выполнения,</p></li><li><p><em>S</em>&#8201;&#8212;&#8201;полученное ускорение (speedup).</p></li></ul></div>
<div class="stemblock"><div class="content">\[\Huge
S = \frac{1}{\alpha+\frac{1-\alpha}{N}} = \frac{N}{1+\alpha(N-1)} \leq \frac{1}{\alpha}\]</div></div>
<div class="paragraph"><p>Вывод: если разделяемая работа составляет 80%, вы не получите более чем пятикратное увеличение производительности за счёт параллелизации.</p></div></section>
<section id="_закон_амдала_поведение"><h2>Закон Амдала: поведение</h2><div class="imageblock" style=""><img src="images/amdahl.png" alt="amdahl" width="80%" /></div></section>
<section id="_на_самом_деле_всё_ещё_хуже"><h2>На самом деле, всё ещё хуже!</h2><div class="ulist"><ul><li><p>Uiversal Scalability Law&#8201;&#8212;&#8201;полуэмпирическое обобщение закона Амдала</p></li><li><p>&beta;&#8201;&#8212;&#8201;параметр, определяющий cohesion (межпоточную координацию)</p></li><li><p>хорошо ложится на эмпирические данные</p></li></ul></div>
<div class="stemblock"><div class="content">\[\Huge
S = \frac{N}{1+\alpha(N-1) + \beta N (N-1)} = \frac{N}{1+(\alpha + \beta N) (N-1)}\]</div></div></section>
<section id="_usl_поведение"><h2>USL: поведение</h2><div class="imageblock" style=""><img src="images/usl.png" alt="usl" width="80%" /></div></section>
<section id="_промежуточный_вывод"><h2>Промежуточный вывод</h2><div class="ulist"><ul><li><p>Перед тем, как встать на скользкую тропу многопоточного программирования, подумайте:</p><div class="ulist"><ul><li><p>нужно ли это для решения задачи?</p></li><li><p>насколько многопоточным должно быть решение?</p></li></ul></div></li><li><p>Вас предупредили.</p></li></ul></div>
<div class="imageblock" style=""><img src="images/hydra1.jpg" alt="hydra1" width="40%" /></div></section>
<section id="_часть_1_зачем_нужна_и_как_достигается_синхронизация"><h2>Часть 1. Зачем нужна и как достигается синхронизация</h2><div class="imageblock" style=""><img src="images/hydra2.jpg" alt="hydra2" width="90%" /></div></section>
<section id="first_example"><h2>Многопоточность в Java (с самой первой версии!)</h2><div class="imageblock" style=""><img src="images/runthr.png" alt="runthr" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">CalcSquare</span> <span class="directive">extends</span> <span class="predefined-type">Thread</span> {
    <span class="directive">final</span> <span class="type">int</span> argument;
    <span class="type">int</span> result;
    CalcSquare(<span class="type">int</span> argument) {
        <span class="local-variable">this</span>.argument = argument;
    }
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run() {
        <span class="comment">//«сложные» вычисления</span>
        result = argument * argument;
    }
}</code></pre></section>
<section id="_запуск_параллельных_вычислений_через_thread_api"><h2>Запуск параллельных вычислений через Thread API</h2><div class="ulist"><ul><li><p>NB: в современной реальности вы не будете пользоваться Thread API</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java">CalcSquare t1 = <span class="keyword">new</span> CalcSquare(<span class="integer">2</span>);
CalcSquare t2 = <span class="keyword">new</span> CalcSquare(<span class="integer">3</span>);
t1.start();
t2.start();
t1.join();
t2.join();
<span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d, %d%n</span><span class="delimiter">&quot;</span></span>, t1.result, t2.result);
<span class="comment">//otput: 4, 9</span></code></pre></section>
<section id="_проблемы_с_shared_state"><h2>Проблемы с shared state</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="imageblock" style=""><img src="images/hydraheads.jpg" alt="hydraheads" /></div></div></td><td class="tableblock halign-left valign-middle"><div><div class="ulist"><ul><li><p>Race condition</p></li><li><p>Stale values</p></li><li><p>Reordering</p></li></ul></div></div></td></tr></table></section>
<section id="_race_condition"><h2>Race condition</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">DumbCounter</span> {
  <span class="type">int</span> count;
  <span class="type">void</span> increment(){
    count++;
  }
}

DumbCounter c1 = <span class="keyword">new</span> DumbCounter();
IntStream.range(<span class="integer">0</span>, <span class="integer">1000000</span>).forEach(i-&gt;c1.increment());

DumbCounter c2 = <span class="keyword">new</span> DumbCounter();
IntStream.range(<span class="integer">0</span>, <span class="integer">1000000</span>).parallel().forEach(i-&gt;c2.increment());

<span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d, %d%n</span><span class="delimiter">&quot;</span></span>, c1.count, c2.count);

<span class="comment">//1000000,??????</span></code></pre></section>
<section id="_stale_values"><h2>Stale values</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">DumbWayToFallAsleep</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {
  <span class="directive">private</span> <span class="type">boolean</span> asleep;

  <span class="directive">public</span> <span class="type">void</span> setAsleep(<span class="type">boolean</span> asleep){
    <span class="local-variable">this</span>.asleep = asleep;
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> run() {
    <span class="keyword">while</span> (!asleep){
      <span class="comment">//countSomeSheep</span>
      <span class="comment">//УСНЁМ ЛИ МЫ?</span>
    }
  }
}</code></pre></section>
<section id="_reordering"><h2>Reordering</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">PossibleReordering</span> {
  <span class="directive">static</span> <span class="type">int</span> x = <span class="integer">0</span>, y = <span class="integer">0</span>, a = <span class="integer">0</span>, b = <span class="integer">0</span>;
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span>... args)
                <span class="directive">throws</span> <span class="exception">InterruptedException</span> {
    <span class="comment">//другой способ запуска треда (тоже не будете пользоваться)</span>
    <span class="predefined-type">Thread</span> one = <span class="keyword">new</span> <span class="predefined-type">Thread</span>(() -&gt; {
        a = <span class="integer">1</span>; x = b;
    });
    <span class="predefined-type">Thread</span> two = <span class="keyword">new</span> <span class="predefined-type">Thread</span>(() -&gt; {
        b = <span class="integer">1</span>; y = a;
    });
    one.start(); two.start();
    one.join();  two.join();
    <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d,%d</span><span class="delimiter">&quot;</span></span>, x, y);
    <span class="comment">//??,??</span>
  }
}</code></pre></section>
<section id="_промежуточные_выводы"><h2>Промежуточные выводы</h2><div class="ulist"><ul><li><p>Из-за reordering и других низкоуровневых особенностей <em>нельзя</em> рассуждать о результате работы одного треда с точки зрения другого треда как о промежуточном результате выполнения исходного кода.</p></li><li><p>Все проблемы с параллельными вычислениями связаны с shared state.</p></li><li><p>Показанные здесь проблемы проявляются недетерминированно.</p></li><li><p>Любая программа с доступом к shared state без должной синхронизации&#8201;&#8212;&#8201;<em>сломана</em>, даже если «вчера это работало на моей машине».</p></li></ul></div></section>
<section id="_модель_памяти"><h2>Модель памяти</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">int</span> aVariable = <span class="integer">42</span>;</code></pre>
<div class="ulist"><ul><li><p>Модель памяти (Java Memory Model, JMM)&#8201;&#8212;&#8201;спецификация языка и виртуальной машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную <code>aVariable</code>, увидит значение 42?»</p></li></ul></div></section>
<section id="_happens_before"><h2>Happens-before</h2><div class="ulist"><ul><li><p>JMM определяет частичный порядок на всех действиях в Java-программе, называемый <em>happens-before</em>.</p></li><li><p>Отношение <em>happens-before</em> транзитивно: \(A \prec B \wedge B \prec C \Rightarrow A \prec C\)</p></li><li><p>Чтобы действие B гарантированно видело результат работы действия A, достаточно, чтобы \(A \prec B\).</p></li></ul></div></section>
<section id="_program_order_rule"><h2>Program order rule</h2><div class="ulist"><ul><li><p>В рамках одного треда все действия <em>happens-before</em> в порядке их определения в исходном коде программы.</p></li><li><p>Иными словами, однопоточные программы выполняются без сюрпризов.</p></li></ul></div></section>
<section id="_thread_start_thread_termination_rule"><h2>Thread start &amp; thread termination rule</h2><div class="ulist"><ul><li><p>Вызов <code>threadA.start()</code> <em>happens-before</em> всех операций в потоке <code>threadA</code>.</p></li><li><p>Любая операция в потоке <code>threadA</code> <em>happens-before</em> обнаружения другим потоком завершения <code>threadA</code>, либо путём выхода из <code>threadA.join()</code>, либо путём проверки <code>threadA.isAlive() == false</code>.</p></li><li><p>Благодаря этому правилу, <a href="#first_example">наш самый первый пример</a> на параллелизацию работает корректно.</p></li></ul></div></section>
<section id="_ключевое_слово_volatile"><h2>Ключевое слово volatile</h2><div class="ulist"><ul><li><p>Переменные классов могут быть определены с ключевым словом <code>volatile</code>.</p></li><li><p><strong>Запись в <code>volatile</code>-переменную <em>happens-before</em> чтения из этой переменной в другом потоке.</strong></p></li><li><p>Это автоматом делает видимыми изменения в других переменных. Полагаться на это не рекомендуется: это работает, но делает код хрупким. В процессе рефакторинга можно поменять порядок доступа к переменным и тем самым незаметно поломать программу.</p></li></ul></div></section>
<section id="_чиним_stale_value_при_помощи_volatile"><h2>Чиним stale value при помощи volatile</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">NotSoDumbWayToFallAsleep</span> <span class="directive">implements</span> <span class="predefined-type">Runnable</span> {
  <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> asleep;

  <span class="directive">public</span> <span class="type">void</span> setAsleep(<span class="type">boolean</span> asleep){
    <span class="local-variable">this</span>.asleep = asleep;
  }

  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">void</span> run() {
    <span class="keyword">while</span> (!asleep){
      <span class="comment">//countSomeSheep</span>
      <span class="comment">//...</span>
    }
  }
}</code></pre></section>
<section id="_final_поля"><h2>final-поля</h2><div class="ulist"><ul><li><p>Если объект правильно опубликован, т. е.  <em>ссылка на него не утекает во время выполнения конструктора</em>&#8201;&#8212;&#8201; <code>final</code>-поля объекта доступны всем тредам без синхронизации.</p></li><li><p>Лучший способ борьбы с проблемами mutable state&#8201;&#8212;&#8201;использовать immutable state где только возможно.</p></li></ul></div></section>
<section id="_неатомарные_операции_final_не_годится_volatile_не_спасёт"><h2>Неатомарные операции: final не годится, volatile не спасёт</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%" /><col style="width:50%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">DumbCounter</span> {
  <span class="type">int</span> count;
  <span class="type">void</span> increment(){
    count++;
  }
}</code></pre>
<div class="paragraph"><p>(Мы можем объявить <code>count</code> как volatile, но ситуация не улучшится.)</p></div></div></td><td class="tableblock halign-left valign-top"><div><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">void</span> dumbMoneyTransfer(
  <span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount){

    accounts[from]-=amount;
    accounts[to]+=amount;
}</code></pre>
<div class="paragraph"><p>(Кстати, <code>volatile array</code>&#8201;&#8212;&#8201;не массив <code>volatile</code>-элементов. И вообще в Java просто так массив <code>volatile</code>-элементов не создать.)</p></div></div></td></tr></table></section>
<section id="_несинхронизированное_выполнение"><h2>Несинхронизированное выполнение</h2><div class="imageblock" style=""><img src="images/nonsync.png" alt="nonsync" /></div></section>
<section id="_синхронизированное_выполнение"><h2>Синхронизированное выполнение</h2><div class="imageblock" style=""><img src="images/sync.png" alt="sync" /></div></section>
<section id="_блокировки"><h2>Блокировки</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//Reentrant так называется потому,</span>
<span class="comment">//что одному и тому же треду позволено входить повторно</span>
<span class="directive">private</span> <span class="predefined-type">ReentrantLock</span> bankLock = <span class="keyword">new</span> <span class="predefined-type">ReentrantLock</span>();

<span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
  bankLock.lock();
  <span class="keyword">try</span> {
    accounts[from]-=amount;
    accounts[to]+=amount;
  } <span class="keyword">finally</span> {
    bankLock.unlock();
  }
}</code></pre>
<div class="paragraph fragment"><p>Если вы задались вопросом: «где гарантии, что после выхода из блокировки тред увидит результат работы предыдущего треда?»&#8201;&#8212;&#8201;поздравляю, вы начали что-то понимать.</p></div></section>
<section id="_jmm_monitor_lock_rule"><h2>JMM Monitor Lock Rule</h2><div class="ulist"><ul><li><p>Разблокировка (unlocking) <em>happens-before</em> другой блокировки (locking) того же самого «замка» (lock).</p></li><li><p>Поэтому защищённые блокировкой переменные объявлять как <code>volatile</code> уже не нужно.</p></li></ul></div></section>
<section id="_в_чём_проблема_здесь"><h2>В чём проблема здесь?</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">while</span> (accounts[from] &lt; amount) {
    <span class="comment">//wait ....</span>
}

bankLock.lock();
<span class="keyword">try</span> {
  <span class="comment">//transfer funds ...</span>
} <span class="keyword">finally</span> {
  bankLock.unlock();
}</code></pre>
<div class="paragraph fragment"><p>Доступ к <code>accounts[from]</code> не синхронизирован, но даже если бы он был синхронизирован, кто-то смог бы уменьшить количество денег до вхождения в блок transfer funds.</p></div></section>
<section id="_в_чём_пробема_здесь"><h2>В чём пробема здесь?</h2><pre class="CodeRay listingblock"><code class="java language-java">bankLock.lock();
<span class="keyword">try</span> {
  <span class="keyword">while</span> (accounts[from] &lt; amount) {
    <span class="comment">//wait ....</span>
  }
  <span class="comment">//transfer funds ...</span>
} <span class="keyword">finally</span> {
  bankLock.unlock();
}</code></pre>
<div class="paragraph fragment"><p>Мы заблокировали <code>bankLock</code> и ждём, пока кто-то закинет денег. Но никто никогда не сможет это сделать, т. к. <code>bankLock</code> занят нами.</p></div></section>
<section id="_condition_objects"><h2>Condition Objects</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">private</span> <span class="predefined-type">ReentrantLock</span> bankLock = <span class="keyword">new</span> <span class="predefined-type">ReentrantLock</span>();
<span class="directive">private</span> <span class="predefined-type">Condition</span> sufficientFunds = bankLock.newCondition();

<span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
  bankLock.lock();
  <span class="keyword">try</span> {
    <span class="keyword">while</span> (accounts[from] &lt; amount)
      sufficientFunds.await();

    accounts[from]-=amount;
    accounts[to]+=amount;

    sufficientFunds.signalAll();
  } <span class="keyword">finally</span> {
    bankLock.unlock();
  }
}</code></pre></section>
<section id="_condition_objects_что_происходит"><h2>Condition Objects: что происходит?</h2><div class="ulist"><ul><li><p><code>await()</code> отпускает блокировку и переводит тред в ждущее состояние,</p></li><li><p><code>signalAll()</code> сигнализирует всем ждущим тредам, что что-то поменялось,</p></li><li><p>выход из <code>await()</code> <em>снова захватывает блокировку</em>.</p></li><li><p>При выходе из <code>await()</code> мы вновь проверяем условие, потому что:</p><div class="ulist"><ul><li><p>сигнал мог быть по другому поводу,</p></li><li><p>возможны «спонтанные пробуждения».</p></li></ul></div></li></ul></div></section>
<section id="_контрольный_вопрос"><h2>Контрольный вопрос</h2><div class="ulist"><ul><li><p>Чем гарантировано, что при выходе из <code>await()</code> мы увидим изменения, сделанные другим тредом?</p></li></ul></div>
<div class="ulist fragment"><ul><li><p>При выходе из <code>await()</code> мы снова захватываем блокировку, работает JMM Monitor Lock Rule.</p></li></ul></div></section>
<section id="_правильный_паттерн_ожидания_condition"><h2>Правильный паттерн ожидания condition</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">while</span> (!okToProceed())
  condition.await();</code></pre></section>
<section id="_intrinsic_lock"><h2>Intrinsic lock</h2><div class="ulist"><ul><li><p>Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.</p></li><li><p>У каждого intrinsic lock есть один condition.</p></li></ul></div></section>
<section id="_то_же_самое_с_помощью_intrinsic_lock"><h2>То же самое, с помощью intrinsic lock</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//enter intrinsic lock on *this*</span>
<span class="directive">synchronized</span> <span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
    <span class="keyword">while</span> (accounts[from] &lt; amount)
      wait(); <span class="comment">//wait on intrinsic object's lock condition</span>

    accounts[from]-=amount;
    accounts[to]+=amount;

    notifyAll(); <span class="comment">//notify all threads waiting on the condition</span>
}</code></pre></section>
<section id="_synchronized_блок"><h2>Synchronized-блок</h2><div class="paragraph"><p>Другая форма использования intrinsic locks:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">private</span> <span class="predefined-type">Object</span> lock = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
<span class="type">void</span> moneyTransfer(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> amount) {
  <span class="directive">synchronized</span> (lock) {
    <span class="keyword">while</span> (accounts[from] &lt; amount)
      lock.wait();

    accounts[from]-=amount;
    accounts[to]+=amount;

    lock.notifyAll();
  }
}</code></pre></section>
<section id="_промежуточный_итог_по_intrinsic_conditions"><h2>Промежуточный итог по intrinsic conditions</h2><div class="ulist"><ul><li><p>Нужно работать по строгому паттерну:</p><div class="ulist"><ul><li><p>синхронизация,</p></li><li><p>while-loop wait,</p></li><li><p>нотификация.</p></li></ul></div></li><li><p>Нужно держать в уме:</p><div class="ulist"><ul><li><p>по intrinsic lock какого объекта синхронизируемся,</p></li><li><p>по condition какого объекта ждём,</p></li><li><p>треды, ждущие на condition какого объекта нотифицируем (это всё должен быть один объект).</p></li></ul></div></li><li><p>В общем, это низкоуровневый и сложный механизм. Его понимание пригодится на собеседованиях, но скорее всего, вам не надо будет им пользоваться.</p></li></ul></div></section>
<section id="_теперь_нам_понятен_смысл_всех_возможных_состояний_треда"><h2>Теперь нам понятен смысл всех возможных состояний треда</h2><div class="imageblock" style=""><img src="images/threadstates.png.png" alt="threadstates.png" /></div></section>
<section id="_промежуточный_итог_по_всему_вышесказанному"><h2>Промежуточный итог по всему вышесказанному</h2><div class="ulist"><ul><li><p>Где возможно, используйте immutable state: он автоматически потокобезопасен.</p></li><li><p>Используйте volatile переменные или синхронизацию для доступа к mutable state.</p></li><li><p>Удерживайте блокировку во время выполнения операций, которые должны быть атомарными.</p></li><li><p>Повторим ещё раз: <strong>программа с shared mutable state без должной синхронизации&#8201;&#8212;&#8201;сломанная программа</strong>.</p></li><li><p>Думайте о потокобезопасности всё время.</p></li><li><p>Понимание JMM помогает</p></li></ul></div></section>
<section id="_часть_2_deadlocks"><h2>Часть 2. Deadlocks</h2><div class="imageblock" style=""><img src="images/hydra2.jpg" alt="hydra2" width="90%" /></div></section>
<section id="_deadlock_простой_пример"><h2>Deadlock: простой пример</h2><div class="imageblock" style=""><img src="images/deadlock.png" alt="deadlock" /></div></section>
<section id="_перепутанный_порядок_блокировки"><h2>Перепутанный порядок блокировки</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">LeftRightDeadlock</span> {
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Object</span> left = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Object</span> right = <span class="keyword">new</span> <span class="predefined-type">Object</span>();
  <span class="type">void</span> leftRight() {
    <span class="directive">synchronized</span> (left) {
      <span class="directive">synchronized</span> (right) {
        doSomething();
      }
    }
  }
  <span class="type">void</span> rightLeft() {
    <span class="directive">synchronized</span> (right) {
      <span class="directive">synchronized</span> (left) {
        doSomethingElse();
      }
    }
  }
}</code></pre></section>
<section id="_перепутанный_иногда_порядок_блокировки"><h2>Перепутанный (иногда!) порядок блокировки</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">void</span> transferMoney(Account fromAccount, Account toAccount,
                     <span class="type">int</span> amount) <span class="directive">throws</span> InsufficientFundsException {
  <span class="directive">synchronized</span> (fromAccount) {
    <span class="directive">synchronized</span> (toAccount) {
      <span class="keyword">if</span> (fromAccount.getBalance() &lt; amount)
        <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();
      <span class="keyword">else</span> {
        fromAccount.debit(amount);
        toAccount.credit(amount);
      }
    }
  }
}</code></pre></section>
<section id="_выводы"><h2>Выводы</h2><div class="ulist"><ul><li><p>Если процедура захватывает несколько блокировок, возможен deadlock.</p></li><li><p>Во избежание deadlocks нужно следить за тем, чтобы блокировки всегда захватывались в одном и том же порядке. Иногда неочевидно, как это сделать.</p></li><li><p>Если вы захватили блокировку&#8201;&#8212;&#8201;закончите с ней как можно быстрее, не вызывайте внешних методов.</p></li></ul></div></section>
<section id="_часть_3_потокобезопасные_структуры_данных"><h2>Часть 3. Потокобезопасные структуры данных</h2><div class="imageblock" style=""><img src="images/hydra2.jpg" alt="hydra2" width="90%" /></div></section>
<section id="_неблокирующие_алгоритмы"><h2>Неблокирующие алгоритмы</h2><div class="ulist"><ul><li><p>Блокировка (через <code>synchronized</code> или <code>ReentrantLock</code>) решает вопрос координации действий разных тредов с переменной.</p></li><li><p>Но если много тредов конкурируют за блокировку (high lock contention), затраты ресурсов на координацию тредов становятся значительными.</p></li><li><p>Альтернативой являются <em>неблокирующие алгоритмы</em>, использующие поддержку специальных атомарных машинных инструкций (compare-and-swap).</p></li><li><p>В Java-библиотеке доступны <em>классы атомарных переменных</em> и <em>потокобезопасные коллекции</em>, реализованные в том числе на неблокирующих алгоритмах.</p></li></ul></div></section>
<section id="_atomics"><h2>Atomics</h2><div class="ulist"><ul><li><p><code>package java.util.concurrent.atomic</code></p><div class="ulist"><ul><li><p><code>AtomicBoolean</code>, <code>AtomicInteger</code>, <code>AtomicLong</code>, <code>AtomicReference</code>.</p></li><li><p><code>AtomicIntegerArray</code>, <code>AtomicLongArray</code>, <code>AtomicReferenceArray</code>.</p></li></ul></div></li><li><p>Могут быть использованы как «улучшенные volatile-переменные», т. к. результат вызова <code>set(&#8230;&#8203;)</code> виден другим тредам при вызове <code>get(&#8230;&#8203;)</code></p></li><li><p>Поддерживают атомарные операции.</p></li></ul></div></section>
<section id="_aтомарные_операции_в_классах_атомарных_переменных"><h2>Aтомарные операции в классах атомарных переменных</h2><pre class="CodeRay listingblock"><code>getAndSet(newValue)    compareAndSet(expect, update)

incrementAndGet()      decrementAndGet()

getAndIncrement()      getAndDecrement()

getAndAdd(delta)       addAndGet(delta)

getAndUpdate(updateFunction)
updateAndGet(updateFunction)

getAndAccumulate(x, accumulatorBiFunction)
accumulateAndGet(x, accumulatorBiFunction)</code></pre></section>
<section id="_потокобезопасные_коллекции"><h2>Потокобезопасные коллекции</h2><div class="ulist"><ul><li><p>В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, обернув в <code>Collections.synchronizedXXX(&#8230;&#8203;)</code>. Это сериализовывало любой доступ к внутреннему состоянию коллекции. Из-за поддержки обратной совместимости сейчас так тоже можно, но не нужно.</p></li><li><p>Цена такого решения&#8201;&#8212;&#8201;плохой параллелизм: конкуренция за блокировку (lock contention).</p></li><li><p>С версии 5 появились классы, специально разработанные для потокобезопасности, с меньшим количеством блокировок.</p></li><li><p>Их использование является <em>предпочтительным</em>.</p></li></ul></div></section></div></div><script src="reveal.js-3.7.0/lib/js/head.min.js"></script><script src="reveal.js-3.7.0/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'none',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1600,
  height: 900,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js-3.7.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'reveal.js-3.7.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js-3.7.0/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>