<!DOCTYPE html><html lang="ru"><head><meta charset="utf-8" /><meta name="author" content="Иван Пономарёв, КУРС/МФТИ" /><title>Core Java: Курс лекций. Лекция 3</title><meta content="yes" name="apple-mobile-web-app-capable" /><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport" /><link href="reveal.js-3.7.0/css/reveal.css" rel="stylesheet" /><link rel="stylesheet" href="white_course.css" id="theme" /><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="./font-awesome-4.7.0/css/font-awesome.css" /><style>/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}</style><link href="reveal.js-3.7.0/lib/css/zenburn.css" rel="stylesheet" /><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js-3.7.0/css/print/pdf.css" : "reveal.js-3.7.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js-3.7.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Core Java</h1><h2>Курс лекций. Лекция 3</h2><div class="preamble"><div class="paragraph"><p><a href="mailto:ponomarev@corchestra.ru">ponomarev@corchestra.ru</a></p></div>
<div class="paragraph"><p><span class="icon"><i class="fa fa-twitter fa-lg"></i></span> @inponomarev</p></div></div><p class="author"><small>Иван Пономарёв, КУРС/МФТИ</small></p></section>
<section id="_три_главных_слова"><div class="imageblock" style=""><img src="images/thethreewords.jpg" alt="thethreewords" width="80%" /></div></section>
<section id="_всё_есть_класс"><h2>Всё есть класс</h2><div class="ulist"><ul><li><p>Любой код&#8201;&#8212;&#8201;метод некоторого класса</p></li><li><p>Любые данные хранятся в полях некоторого класса</p></li><li><p>Любые типы данных (исключая примитивные, но включая массивы)&#8201;&#8212;&#8201;наследники класса <code>Object</code></p></li></ul></div></section>
<section id="_классы_помещаются_в_пакеты"><h2>Классы помещаются в пакеты</h2><div class="ulist"><ul><li><p><code>edu.phystech.foo</code></p></li><li><p><code>edu.phystech.foo.bar</code></p></li><li><p>Каждый .java-файл начинается с объявления пакета:<br />
<code>package edu.phystech.hello;</code></p></li><li><p>В корне пакета может быть <code>package-info.java</code>, не содержащий классы, а только JavaDoc над ключевым словом <code>package</code>.</p></li><li><p>&lt;Имя пакета&gt;.&lt;имя класса&gt; задаёт полный идентификатор любого класса, доступного в исходном коде или через библиотеки (например, <code>edu.phystech.hello.App</code>)</p></li><li><p>Вложенные пакеты&#8201;&#8212;&#8201;это <em>разные</em> пакеты с точки зрения Java (package-private классы одного пакета не будут видны в другом)</p></li></ul></div></section>
<section id="_структура_класса_переменные_конструкторы_и_методы"><h2>Структура класса: переменные, конструкторы и методы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">ClassName</span>
{
   field1
   field2
   . . .
   constructor1
   constructor2
   . . .
   method1
   method2
   . . .
}</code></pre></section>
<section id="_определяем_класс"><h2>Определяем класс</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">package</span> <span class="namespace">org.megacompany.staff</span>;
<span class="type">class</span> <span class="class">Employee</span> {
  <span class="comment">// instance fields</span>
  <span class="directive">private</span> <span class="predefined-type">String</span> name;
  <span class="directive">private</span> <span class="type">double</span> salary;
  <span class="directive">private</span> LocalDate hireDay;
  <span class="comment">// constructor</span>
  <span class="directive">public</span> Employee(<span class="predefined-type">String</span> n, <span class="type">double</span> s, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) {
    name = n;
    salary = s;
    hireDay = LocalDate.of(year, month, day);
  }
  <span class="comment">// a method</span>
  <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
    <span class="keyword">return</span> name;
  }
  <span class="comment">// more methods</span>
  . . .
}</code></pre></section>
<section id="_создаём_и_используем_экземпляры_класса"><h2>Создаём и используем экземпляры класса</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//При необходимости, импортируем</span>
<span class="keyword">import</span> <span class="include">org.megacompany.staff.Employee</span>;

<span class="comment">//где-то в теле метода</span>
. . .
Employee hacker = <span class="keyword">new</span> Employee(<span class="string"><span class="delimiter">&quot;</span><span class="content">Harry Hacker</span><span class="delimiter">&quot;</span></span>, <span class="integer">50000</span>, <span class="integer">1989</span>, <span class="integer">10</span>, <span class="integer">1</span>);
Employee tester = <span class="keyword">new</span> Employee(<span class="string"><span class="delimiter">&quot;</span><span class="content">Tommy Tester</span><span class="delimiter">&quot;</span></span>, <span class="integer">40000</span>, <span class="integer">1990</span>, <span class="integer">3</span>, <span class="integer">15</span>);

hacker.getName(); <span class="comment">//returns &quot;Harry Hacker&quot;</span></code></pre></section>
<section id="_про_инициализацию_полей"><h2>Про инициализацию полей</h2><div class="ulist"><ul><li><p>В отличие от локальных переменных, поля можно не инициализировать явно.</p></li><li><p>В этом случае примитивные типы получают значение по умолчанию (<code>0</code>, <code>false</code>), а поля со ссылками&#8201;&#8212;&#8201;значение <code>null</code>.</p></li><li><p>Проинициализировать поле по месту его определения не возбраняется:<br />
<code>int a = 42</code> или даже <code>int a = getValue()</code>.</p></li></ul></div></section>
<section id="_поле_this"><h2>Поле this</h2><pre class="CodeRay listingblock"><code class="java language-java">{ ...

  int value;

  setValue(<span class="type">int</span> value) {
    <span class="comment">//поле перекрыто аргументом</span>
    <span class="local-variable">this</span>.value = value;
  }

  registerMe(Registrator r) {
    <span class="comment">//нужна ссылка на себя</span>
    r.register(<span class="local-variable">this</span>);
  }
}</code></pre></section>
<section id="_объект_передаётся_по_ссылке"><h2>Объект передаётся по ссылке!</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Employee</span> {
    <span class="type">int</span> age = <span class="integer">18</span>;

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        Employee e = <span class="keyword">new</span> Employee();
        <span class="type">int</span> a = <span class="integer">1</span>;
        foo(e, a);
        <span class="predefined-type">System</span>.out.printf(<span class="string"><span class="delimiter">&quot;</span><span class="content">%d - %d</span><span class="delimiter">&quot;</span></span>, e.age, a);
        <span class="comment">//prints 42 - 1</span>
    }

    <span class="directive">static</span> <span class="type">void</span> foo(Employee e, <span class="type">int</span> a) {
        <span class="comment">//e passed by reference, a passed by value</span>
        e.age = <span class="integer">42</span>;
        a = <span class="integer">5</span>;
    }
}</code></pre></section>
<section id="_рождение_жизнь_и_смерть_объекта"><h2>Рождение, жизнь и смерть объекта</h2><div class="ulist"><ul><li><p>Создание: <code>new Employee(..)</code></p></li><li><p>Присвоение ссылки: <code>Employee hacker = &#8230;&#8203;</code></p></li><li><p>Потеря ссылки</p></li><li><p>Сборка мусора</p></li></ul></div></section>
<section id="_области_видимости"><h2>Области видимости</h2><table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:40%" /><col style="width:60%" /></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Область видимости</strong></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><strong>Кому доступно</strong></p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>private</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>только классу</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>package-private</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>только пакету (по умолчанию)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>protected</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>классу, пакету, и классам-наследникам</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p><code>public</code></p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>всем</p></div></div></td></tr></table></section>
<section id="_файлы_с_исходным_кодом_и_классы"><h2>Файлы с исходным кодом и классы</h2><div class="ulist"><ul><li><p>В одном .java файле может быть один публичный класс, названный так же, как и .java-файл (<code>public class Foo</code> в файле <code>Foo.java</code>).</p></li><li><p>Может быть сколько угодно package-private-классов, но это скорее плохая практика.</p></li></ul></div></section>
<section id="_наследование"><h2>Наследование</h2><div class="imageblock" style=""><img src="images/employeemanager.png" alt="employeemanager" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Manager</span> <span class="directive">extends</span> Employee {
  <span class="directive">private</span> <span class="type">double</span> bonus;
  . . .
  public <span class="type">void</span> setBonus(<span class="type">double</span> bonus) {
    <span class="local-variable">this</span>.bonus = bonus;
  }
}</code></pre></section>
<section id="_наследование_2"><h2>Наследование</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">// construct a Manager object</span>
Manager boss = <span class="keyword">new</span> Manager(<span class="string"><span class="delimiter">&quot;</span><span class="content">Carl Cracker</span><span class="delimiter">&quot;</span></span>, <span class="integer">80000</span>, <span class="integer">1987</span>, <span class="integer">12</span>, <span class="integer">15</span>);
boss.setBonus(<span class="integer">5000</span>);
Employee<span class="type">[]</span> staff = <span class="keyword">new</span> Employee[<span class="integer">3</span>];
staff[<span class="integer">0</span>] = boss;
staff[<span class="integer">1</span>] = <span class="keyword">new</span> Employee(<span class="string"><span class="delimiter">&quot;</span><span class="content">Harry Hacker</span><span class="delimiter">&quot;</span></span>, <span class="integer">50000</span>, <span class="integer">1989</span>, <span class="integer">10</span>, <span class="integer">1</span>);
staff[<span class="integer">2</span>] = <span class="keyword">new</span> Employee(<span class="string"><span class="delimiter">&quot;</span><span class="content">Tommy Tester</span><span class="delimiter">&quot;</span></span>, <span class="integer">40000</span>, <span class="integer">1990</span>, <span class="integer">3</span>, <span class="integer">15</span>);

<span class="keyword">for</span> (Employee e : staff)
  <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">name=</span><span class="delimiter">&quot;</span></span> + e.getName() + <span class="string"><span class="delimiter">&quot;</span><span class="content">,salary=</span><span class="delimiter">&quot;</span></span> + e.getSalary());</code></pre></section>
<section id="_наследование_единственный_родительский_класс"><h2>Наследование: единственный родительский класс</h2><div class="imageblock" style=""><img src="images/columnclasses.png" alt="columnclasses" /></div></section>
<section id="_тип_ссылки_и_тип_объекта"><h2>Тип ссылки и тип объекта</h2><div class="imageblock" style=""><img src="images/employeemanagerex.png" alt="employeemanagerex" /></div>
<pre class="CodeRay listingblock"><code class="java language-java">  Executive ex = <span class="keyword">new</span> Executive (...);
  <span class="comment">//для ex доступны члены, объявленные в Manager, Employee и Executive</span>
  Manager m = ex;
  <span class="comment">//для m доступны члены, объявленные в Employee и Manager</span>
  Employee e = e;
  <span class="comment">//для e доступны члены, объявленные только в Employee</span></code></pre></section>
<section id="_eщё_раз_про_ковариантность_массивов"><h2>Eщё раз про ковариантность массивов</h2><pre class="CodeRay listingblock"><code class="java language-java">Manager<span class="type">[]</span> managers = <span class="keyword">new</span> Manager[<span class="integer">10</span>];
Employee<span class="type">[]</span> staff = managers;
staff[<span class="integer">0</span>] = <span class="keyword">new</span> Employee(<span class="string"><span class="delimiter">&quot;</span><span class="content">Harry Hacker</span><span class="delimiter">&quot;</span></span>, . . .); <span class="comment">//ArrayStoreException.</span></code></pre>
<div class="paragraph"><p>Правда жизни: массивы&#8201;&#8212;&#8201;низкоуровневая возможность языка и в промышленном коде не используются</p></div></section>
<section id="_переопределение_overriding_методов"><h2>Переопределение (overriding) методов</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Employee</span> {
  <span class="directive">private</span> <span class="type">int</span> salary;
  <span class="directive">public</span> <span class="type">int</span> getSalary() {
    <span class="keyword">return</span> salary;
  }
  <span class="directive">public</span> <span class="type">int</span> getTotalPayout(){
    <span class="keyword">return</span> getSalary();
  }
}

<span class="type">class</span> <span class="class">Manager</span> <span class="directive">extends</span> Employee {
  <span class="directive">private</span> <span class="type">int</span> bonus;
  <span class="annotation">@Override</span> <span class="comment">//не обязательная, но крайне желательная штука</span>
  <span class="directive">public</span> <span class="type">int</span> getTotalPayout() {
    <span class="keyword">return</span> getSalary() + bonus;
  }
}</code></pre></section>
<section id="_вариант"><h2>Вариант</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Manager</span> <span class="directive">extends</span> Employee {
  <span class="directive">private</span> <span class="type">int</span> bonus;
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="type">int</span> getTotalPayout() {
    <span class="keyword">return</span> <span class="local-variable">super</span>.getTotalPayout() + bonus;
  }
}</code></pre></section>
<section id="_final_классы_и_методы"><h2>final-классы и методы</h2><div class="ulist"><ul><li><p>Ключевое слово <code>final</code>:</p><div class="ulist"><ul><li><p>на уровне класса запрещает наследование класса</p></li><li><p>на уровне метода запрещает наследование метода</p></li></ul></div></li><li><p>Зачем это нужно?</p><div class="ulist"><ul><li><p>Паттерн "Шаблонный метод"</p></li><li><p>J. Bloch: 'Design and document for inheritance, or else prohibit it'</p></li></ul></div></li></ul></div></section>
<section id="_перегрузка_overloading_методов"><h2>Перегрузка (overloading) методов</h2><div class="paragraph"><p>Сигнатура метода определяется его названием и типами аргументов:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//org.junit.jupiter.api.Assertions</span>
<span class="type">void</span> assertEquals(<span class="type">short</span> expected, <span class="type">short</span> actual)
<span class="type">void</span> assertEquals(<span class="type">short</span> expected, <span class="type">short</span> actual, <span class="predefined-type">String</span> message)
<span class="type">void</span> assertEquals(<span class="type">short</span> expected, <span class="type">short</span> actual, Supplier&lt;<span class="predefined-type">String</span>&gt; messageSupplier)
<span class="type">void</span> assertEquals(<span class="type">byte</span> expected, <span class="type">byte</span> actual)
<span class="type">void</span> assertEquals(<span class="type">byte</span> expected, <span class="type">byte</span> actual, <span class="predefined-type">String</span> message)
<span class="type">void</span> assertEquals(<span class="type">byte</span> expected, <span class="type">byte</span> actual, Supplier&lt;<span class="predefined-type">String</span>&gt; messageSupplier)
<span class="type">void</span> assertEquals(<span class="type">int</span> expected, <span class="type">int</span> actual)
<span class="type">void</span> assertEquals(<span class="type">int</span> expected, <span class="type">int</span> actual, <span class="predefined-type">String</span> message)
<span class="type">void</span> assertEquals(<span class="type">int</span> expected, <span class="type">int</span> actual, Supplier&lt;<span class="predefined-type">String</span>&gt; messageSupplier)
. . .</code></pre></section>
<section id="_статические_поля_и_методы"><h2>Статические поля и методы</h2><div class="paragraph"><p>Данные, общие для всех экземпляров класса:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Employee</span> {
  <span class="comment">/*WARNING: данный пример
  не работает при многопоточном исполнении*/</span>
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> nextId = <span class="integer">1</span>;
  <span class="directive">private</span> <span class="type">int</span> id;
  . . .
  public <span class="type">void</span> setId() {
    id = nextId;
    nextId++;
  }
}</code></pre></section>
<section id="_статические_константы"><h2>Статические константы</h2><div class="paragraph"><p>Выделяем память один раз</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Math</span> {
   . . .
   public <span class="directive">static</span> <span class="directive">final</span> <span class="type">double</span> PI = <span class="float">3.14159265358979323846</span>;
   . . .
}


. . .

Math.PI <span class="comment">// возвращает 3.14...</span></code></pre></section>
<section id="_статические_методы"><h2>Статические методы</h2><div class="paragraph"><p>Статическим методам доступны только статические переменные и вызовы других статических методов</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Employee</span> {

  <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> nextId = <span class="integer">1</span>;
  <span class="directive">private</span> <span class="type">int</span> id;
  . . .
  public <span class="directive">static</span> <span class="type">int</span> getNextId() {
    <span class="keyword">return</span> nextId; <span class="comment">// returns static field</span>
  }
}

. . .
Employee.nextId() <span class="comment">//имя класса вместо объекта</span></code></pre></section>
<section id="_psvm"><h2>psvm</h2><div class="paragraph"><p>Теперь мы понимаем: метод main доступен всем и не требует инстанцирования объекта:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">App</span> {
  <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span>... args) {
     <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello, world!</span><span class="delimiter">&quot;</span></span>);
  }
}</code></pre></section>
<section id="_конструкторы_демо"><h2>Конструкторы: ДЕМО</h2><div class="ulist"><ul><li><p>Конструктор <em>обязан</em> быть.</p></li><li><p>Если мы 1) явно не написали конструктор, 2) родительский класс имеет конструктор без аргументов&#8201;&#8212;&#8201;то неявным образом у класса появляется публичный конструктор без аргументов по умолчанию.</p></li><li><p>Если мы явно написали хотя бы один конструктор,  конструктор по умолчанию <em>исчезает</em>.</p></li><li><p>Если в родительском классе нет конструктора без аргументов, конструктор по умолчанию <em>не создаётся</em>.</p></li><li><p>Конструктор <em>не обязан быть публичным</em>.</p></li></ul></div></section>
<section id="_переопределение_конструкторов_при_наследовании_классов_демо"><h2>Переопределение конструкторов при наследовании классов: ДЕМО</h2><div class="ulist"><ul><li><p>Если у суперкласса нет конструктора без аргументов, первым вызовом должен быть <code>super(&#8230;&#8203;)</code>.</p></li></ul></div></section>
<section id="_перегрузка_конструкторов_демо"><h2>Перегрузка конструкторов: ДЕМО</h2><div class="ulist"><ul><li><p>Вызов <code>this(&#8230;&#8203;)</code></p></li></ul></div></section>
<section id="_секции_инициализации"><h2>Секции инициализации</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Employee</span> {
  <span class="directive">private</span> <span class="directive">static</span> <span class="type">int</span> nextId;
  <span class="directive">private</span> <span class="type">int</span> id;

  <span class="comment">// static initialization block</span>
  <span class="directive">static</span> {
    nextId = ThreadLocalRandom.current().nextInt(<span class="integer">10000</span>);
  }

  <span class="comment">// object initialization block</span>
  {
    id = nextId;
    nextId++;
  }
}</code></pre></section>
<section id="_а_как_же_деструктор"><h2>А как же деструктор?</h2><div class="ulist"><ul><li><p>А его нет!</p></li><li><p>Даже не пытайтесь переопределять <code>finalize</code></p></li><li><p>Почему метод <code>finalize</code> оказался плохой идеей</p></li></ul></div></section>
<section id="_абстрактные_классы_и_методы"><h2>Абстрактные классы и методы</h2><div class="imageblock" style=""><img src="images/abstractsample.png" alt="abstractsample" /></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Person</span>
{
  <span class="directive">public</span> Person(<span class="predefined-type">String</span> name) {
    <span class="local-variable">this</span>.name = name;
  }
  <span class="directive">public</span> <span class="predefined-type">String</span> getName() {
    <span class="keyword">return</span> name;
  }
  <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> getDescription();
}</code></pre></section>
<section id="_реализация_абстрактного_класса"><h2>Реализация абстрактного класса</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Student</span> <span class="directive">extends</span> Person
{
  <span class="directive">private</span> <span class="predefined-type">String</span> major;
  <span class="directive">public</span> Student(<span class="predefined-type">String</span> name, <span class="predefined-type">String</span> major) {
    <span class="local-variable">super</span>(name);
    <span class="local-variable">this</span>.major = major;
  }
  <span class="annotation">@Override</span>
  <span class="directive">public</span> <span class="predefined-type">String</span> getDescription() {
    <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a student majoring in </span><span class="delimiter">&quot;</span></span> + major;
  }
}</code></pre></section>
<section id="_правила"><h2>Правила</h2><div class="ulist"><ul><li><p>Класс, в котором хотя бы один из методов не реализован, должен быть помечен как <code>abstract</code></p></li><li><p>Нереализованные методы в классе возникают двумя способами:</p><div class="ulist"><ul><li><p>явно объявлены как <code>abstract</code></p></li><li><p>унаследованы из абстрактных классов или интерфейсов и не переопределены.</p></li></ul></div></li><li><p>Абстрактные классы нельзя инстанцировать через new.</p><div class="ulist"><ul><li><p><code>new Person("John Doe");</code>&#8201;&#8212;&#8201;ошибка компиляции: 'Person is abstract, cannot be intantiated'.</p></li></ul></div></li></ul></div></section>
<section id="_интерфейсы"><h2>Интерфейсы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="comment">//его нельзя инстацировать!</span>
<span class="directive">public</span> <span class="type">interface</span> <span class="class">Prism</span>
{
   <span class="comment">//это --- final-переменная!</span>
   <span class="type">double</span> PI = <span class="float">3.14</span>;

   <span class="comment">//это --- публичные абстрактные методы!</span>
   <span class="type">double</span> getArea();
   <span class="type">double</span> getHeight();

   <span class="comment">//этот метод может вызывать другие и читать final-поля</span>
   <span class="keyword">default</span> <span class="type">double</span> getVolume() {
      <span class="keyword">return</span> getArea() * getHeight();
   }
}</code></pre></section>
<section id="_реализация_интерфейса"><h2>Реализация интерфейса</h2><pre class="CodeRay listingblock"><code class="java language-java">puplic <span class="type">class</span> <span class="class">Parallelepiped</span> <span class="directive">implements</span> Prism {
    <span class="directive">private</span> <span class="type">double</span> a;
    <span class="directive">private</span> <span class="type">double</span> b;
    <span class="directive">private</span> <span class="type">double</span> h;
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">double</span> getArea() {
        <span class="keyword">return</span> a * b;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">double</span> getHeight() {
        <span class="keyword">return</span> h;
    }
}</code></pre>
<div class="paragraph"><p>Если какой-то из методов интерфейса не будет переопределён, класс нужно пометить как abstract.</p></div></section>
<section id="_чем_интерфейсы_отличаются_от_абстрактных_классов"><h2>Чем интерфейсы отличаются от абстрактных классов?</h2><div class="ulist"><ul><li><p>Нет внутреннего состояния и конструкторов</p></li><li><p>Можно наследоваться (<code>extends</code>) только от одного класса, но реализовывать (<code>implements</code>) сколько угодно интерфейсов&#8201;&#8212;&#8201;<em>множественное наследование</em>.</p></li><li><p>Поэтому как абстракция, интерфейс предпочтительнее.</p></li></ul></div></section>
<section id="_оператор_instanceof"><h2>Оператор instanceof</h2><div class="imageblock" style=""><img src="images/instanceof.png" alt="instanceof" /></div>
<pre class="CodeRay listingblock"><code class="java language-java">C1 c1; C2 c2; C3 c3; I1 i1;

x <span class="keyword">instanceof</span> A <span class="comment">//  false, если x == null</span>
c1 <span class="keyword">instanceof</span> <span class="error">С</span><span class="integer">2</span> <span class="comment">// true или false</span>
I1 <span class="keyword">instanceof</span> C2 <span class="comment">// true или false</span>
c2 <span class="keyword">instanceof</span> C1 <span class="comment">// всегда возвращает true</span>
<span class="error">с</span><span class="integer">3</span> <span class="keyword">instanceof</span> C2 <span class="comment">// не скомпилируется</span></code></pre></section>
<section id="_приведение_типов"><h2>Приведение типов</h2><pre class="CodeRay listingblock"><code class="java language-java">Person p = . . .;
<span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) {
    <span class="comment">//если не защитить instanceof, возможен ClassCastException</span>
    Student s = (Student) p;
    . . .
}</code></pre></section>
<section id="_небольшое_отступление_про_pattern_matching"><h2>Небольшое отступление про Pattern Matching</h2><div class="paragraph"><p>Слайд из доклада Т. Валеева "Pattern Matching и его воображаемые друзья"</p></div>
<div class="imageblock" style=""><img src="images/patternmatching.png" alt="patternmatching" /></div></section>
<section id="_в_котлине_так"><h2>В Котлине так</h2><pre class="CodeRay listingblock"><code class="kotlin language-kotlin">fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x is automatically cast to String
    }
}</code></pre></section>
<section id="_вложенные_классы"><h2>Вложенные классы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Outer</span> {
   <span class="type">int</span> field = <span class="integer">42</span>;
   <span class="type">class</span> <span class="class">Inner</span> {
      <span class="directive">public</span> <span class="type">void</span> show() {
           <span class="comment">//есть доступ к состоянию внешнего класса!</span>
           <span class="predefined-type">System</span>.out.println(field);
           <span class="comment">//печатает 42</span>
      }
   }
   <span class="type">void</span> initInner(){
     <span class="comment">//инициализация вложенного класса внутри</span>
     <span class="keyword">new</span> Inner();
   }
}

<span class="comment">//инициализация вложенного класса извне</span>
Outer.Inner in = <span class="keyword">new</span> Outer().new Inner();</code></pre></section>
<section id="_вложенные_классы_2"><h2>Вложенные классы</h2><div class="paragraph"><p>Каждый экземпляр <code>Inner</code> имеет неявную ссылку на <code>Outer</code>.</p></div>
<div class="imageblock" style=""><img src="images/inner.png" alt="inner" /></div></section>
<section id="_вложенные_классы_3"><h2>Вложенные классы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Outer</span> {
   <span class="type">int</span> field = <span class="integer">42</span>;
   <span class="type">class</span> <span class="class">Inner</span> {
      <span class="comment">//поле вложенного класса перекрывает поле внешнего класса</span>
      <span class="type">int</span> field = <span class="integer">18</span>;
      <span class="directive">public</span> <span class="type">void</span> show() {
           <span class="predefined-type">System</span>.out.println(field);
           <span class="comment">//печатает 18</span>
      }
   }
}</code></pre></section>
<section id="_вложенные_классы_4"><h2>Вложенные классы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Outer</span> {
   <span class="type">int</span> field = <span class="integer">42</span>;
   <span class="type">class</span> <span class="class">Inner</span> {
      <span class="comment">//поле вложенного класса перекрывает поле внешнего класса</span>
      <span class="type">int</span> field = <span class="integer">18</span>;
      <span class="directive">public</span> <span class="type">void</span> show() {
           <span class="predefined-type">System</span>.out.println(Outer.this.field);
           <span class="comment">//печатает 42!</span>
      }
   }
}</code></pre></section>
<section id="_локальные_вложенные_классы"><h2>Локальные вложенные классы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Outer</span> {
   <span class="type">void</span> outerMethod() {
      <span class="comment">//final (или effectively final) тут существенно</span>
      <span class="directive">final</span> <span class="type">int</span> x = <span class="integer">98</span>;
      <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">inside outerMethod</span><span class="delimiter">&quot;</span></span>);
      <span class="type">class</span> <span class="class">Inner</span> {
         <span class="type">void</span> innerMethod() {
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">x = </span><span class="delimiter">&quot;</span></span> + x);
         }
      }
      Inner y = <span class="keyword">new</span> Inner();
      y.innerMethod();
   }
}</code></pre></section>
<section id="_вложенные_статические_классы"><h2>Вложенные статические классы</h2><div class="paragraph"><p>По сути, ничем не отличаются от просто классов:</p></div>
<pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Outer</span> {
   <span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> outerMethod() {
     <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">inside outerMethod</span><span class="delimiter">&quot;</span></span>);
   }
   <span class="directive">static</span> <span class="type">class</span> <span class="class">Inner</span> {
     <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">inside inner class Method</span><span class="delimiter">&quot;</span></span>);
        outerMethod();
     }
   }
}
. . .
Outer.Inner x = <span class="keyword">new</span> Outer.Inner();
<span class="comment">// в отличие от не статического: new Outer().new Inner();</span></code></pre></section>
<section id="_анонимные_классы"><h2>Анонимные классы</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="type">class</span> <span class="class">Demo</span> {
    <span class="type">void</span> show() {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">superclass</span><span class="delimiter">&quot;</span></span>);
    }
}
<span class="type">class</span> <span class="class">Flavor1Demo</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args){
        Demo d = <span class="keyword">new</span> Demo() {
            <span class="type">void</span> show() {
                <span class="local-variable">super</span>.show();
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">subclass</span><span class="delimiter">&quot;</span></span>);
            }
        };
        d.show();
    }
}</code></pre></section>
<section id="_использование_анонимных_классов"><h2>Использование анонимных классов</h2><div class="ulist"><ul><li><p>Чаще всего&#8201;&#8212;&#8201;как реализация абстрактных классов и интерфейсов "по месту"</p></li><li><p>Анонимный класс&#8201;&#8212;&#8201;вложенный класс, поэтому до появления лямбд и ссылок на методы это был единственный способ организовать коллбэк</p></li></ul></div>
<pre class="CodeRay listingblock"><code class="java language-java">. . .
button.onMouseClick(<span class="keyword">new</span> <span class="predefined-type">EventListener</span>(){
  <span class="type">void</span> onClick(<span class="predefined-type">Event</span> e) {
     <span class="comment">//здесь у нас доступ ко всем внешним полям</span>
     <span class="comment">//и effectively final-переменным</span>
  }
});</code></pre></section>
<section id="_object_the_cosmic_superclass"><h2>Object: the Cosmic Superclass</h2><div class="ulist"><ul><li><p>Любой класс в Java является наследником <code>Object</code></p></li><li><p>Писать <code>class Employee extends Object</code> не надо</p></li><li><p>В этом классе определены важные методы</p><div class="ulist"><ul><li><p><code>equals</code> и <code>hashCode</code></p></li><li><p><code>toString</code></p></li></ul></div></li></ul></div></section>
<section id="_контракты_equals_и_hashcode"><h2>Контракты equals() и hashCode()</h2><div class="ulist"><ul><li><p><code>boolean equals(Object other)</code> возвращает <code>true</code> т. и т. т., когда внутреннее состояние совпадает</p></li><li><p><code>int hashCode()</code> возвращает целое значение, которое обязано совпадать для объектов с одинаковым внутренним состоянием</p></li><li><p>Реализация на уровне <code>Object</code> работает только для совпадающих объектов</p></li><li><p>понятие <em>одинаковости внутреннего состояния</em> должно совпадать для <code>equals</code> и <code>hashCode</code>.</p></li><li><p>На самом деле это нужно для хеш-таблиц (и, пожалуй, является протекшей абстракцией)</p></li></ul></div></section>
<section id="_генерация_equals_hashcode"><h2>Генерация equals-hashCode</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {
    <span class="directive">private</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="type">int</span> age;
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="predefined-type">Object</span> o) {
       <span class="comment">// никогда, НИКОГДА не пытайтесь писать эту ерунду сами</span>
        <span class="keyword">if</span> (<span class="local-variable">this</span> == o) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        <span class="keyword">if</span> (o == <span class="predefined-constant">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        Person person = (Person) o;
        <span class="keyword">return</span> age == person.age &amp;&amp;
                Objects.equals(name, person.name);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> hashCode() {
        <span class="keyword">return</span> Objects.hash(name, age);
    }
}</code></pre></section>
<section id="_или_если_у_нас_lombok"><h2>Или, если у нас Lombok</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">import</span> <span class="include">lombok.EqualsAndHashCode</span>;

<span class="annotation">@EqualsAndHashCode</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {
    <span class="directive">private</span>  <span class="type">int</span> age;
    <span class="directive">private</span>  <span class="predefined-type">String</span> name;
}</code></pre></section>
<section id="_переопределение_tostring"><h2>Переопределение toString</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {
    <span class="directive">private</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="type">int</span> age;
    . . .
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Person{</span><span class="delimiter">&quot;</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">name='</span><span class="delimiter">&quot;</span></span> + name + <span class="string"><span class="delimiter">'</span><span class="char">\'</span><span class="delimiter">'</span></span> +
                <span class="string"><span class="delimiter">&quot;</span><span class="content">, age=</span><span class="delimiter">&quot;</span></span> + age +
                <span class="string"><span class="delimiter">'</span><span class="content">}</span><span class="delimiter">'</span></span>;
    }
}


. . .
Person person = . . .
System.out.println(person);</code></pre></section>
<section id="_или_если_у_нас_lombok_2"><h2>Или, если у нас Lombok</h2><pre class="CodeRay listingblock"><code class="java language-java"><span class="keyword">import</span> <span class="include">lombok.ToString</span>;

<span class="annotation">@ToString</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Person</span> {
    <span class="directive">private</span>  <span class="type">int</span> age;
    <span class="directive">private</span>  <span class="predefined-type">String</span> name;
}</code></pre></section></div></div><script src="reveal.js-3.7.0/lib/js/head.min.js"></script><script src="reveal.js-3.7.0/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: true,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: false,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'none',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 1600,
  height: 900,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js-3.7.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'reveal.js-3.7.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js-3.7.0/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>